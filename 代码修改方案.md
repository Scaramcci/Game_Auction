# 代码修改

下面给出 3 个层次的改进思路，帮助你从目前 **“价格-利润-方差”** 三张图，进一步得到论文常见的 **市场深度（价格冲击系数 λₜ）、交易强度 βₜ、价格影响回归 R²、信息泄露速率** 等结果，并与理论式子对比。



------





## **1 | 在** 

## **env.py**

##  **里实时记录 λₜ 与 βₜ**



```
# env.py 片段 —— 在 __init__ 里加两个列表
self.lambda_hist, self.beta_hist = [], []

# 在 step() 里：
x = float(action[0])                          # Insider 下单
...
# === ① 估算本轮“经验 βₜ” ===
if abs(self.v - prev_price) > 1e-8:
    beta_hat = x / (self.v - prev_price)
else:
    beta_hat = 0.0
self.beta_hist.append(beta_hat)

# === ② 储存 λₜ（这里是常数，若改成动态公式就把 lambda_val 换成 λₜ） ===
self.lambda_hist.append(self.lambda_val)

# === ③ 其余逻辑保持不变
```

这样每个 episode 结束后，env.lambda_hist 和 env.beta_hist 就存好了 1…T 轮的 λ、β 数列，可拿来画线对比理论。



*如果想让 λₜ 动态随信息量变化*：

```
# 根据 Kyle 理论： λₜ = prior_var / (prior_var + σ_u²/βₜ²)
self.lambda_val = self.current_var / (self.current_var + self.sigma_u**2 / max(beta_hat**2,1e-8))
```

再把 self.lambda_val 用来更新价格；这样市场深度会越来越大（λ 递减）。



------





## **2 | 在** 

## **visualize.py**

##  **里批量采样，回归实证 λ**





论文里常见做法是用 **横截面回归** 来估计“经验价格冲击”：



\widehat\lambda \;=\; \frac{\sum_t \Delta p_t Q_t}{\sum_t Q_t^2}, \quad \text{其中 }\;\Delta p_t = p_t - p_{t-1},\; Q_t = x_t+u_t



把这一段加到 visualize.py，甚至跑 1 000 个 episode 取平均即可：

```
import numpy as np, pandas as pd
EPISODES = 1000
rows = []
for _ in range(EPISODES):
    obs = env.reset()
    done = False
    while not done:
        action, _ = model.predict(obs, deterministic=True)
        prev_p = env.current_price
        obs, _, done, info = env.step(action)
        rows.append({
            'dP': env.current_price - prev_p,
            'Q' : env.lambda_hist[-1]*0 + (action[0] + info['noise'])  # Q_t
        })
df = pd.DataFrame(rows)
lambda_reg = (df['dP']*df['Q']).sum() / (df['Q']**2).sum()
print(f"回归得到 λ ≈ {lambda_reg:.3f}")
```

> **可视化**：

> plt.plot(env.lambda_hist, label='模型 λ_t'), plt.hlines(lambda_reg,0,T-1,linestyle='--')



------





## **3 | 结果对照与论文指标**



| **论文指标**             | **你的代码要补什么**                           | **参考理论值**                                        |
| ------------------------ | ---------------------------------------------- | ----------------------------------------------------- |
| **价格冲击 λₜ (1/深度)** | ① 记录 λₜ；② 批量回归估计；③ 画 λₜ 随 t 递减图 | 若 βₜ 固定： λ ≈ 1 / (2 β)                            |
| **交易强度 βₜ**          | 记录 x / (v−p_{t-1})；画随 t 递增曲线          | 单期 β = σᵤ / √Σ_{t-1}; 多期向末轮递增                |
| **信息泄露速率**         | 已有 Var[v                                     | p]；再加 -np.diff(np.log(var_history)) 作对数收敛速率 |
| **价格效率 R²**          | 回归 v ~ p_T（终值）或 Δp_t ~ v；输出 R²       | 理论趋近 1 随 T↑、σᵤ↓                                 |
| **市场深度 LOB**         | 若采用订单簿库 (pymarket)，记录挂单深度分布    | 深度与 λ 成反比                                       |



------





### **小贴士**





1. **保持 βₜ ≈ 解析值**

   

   - 训练后打印 np.mean(env.beta_hist, axis=0) 与公式比；若偏差大，可在 reward 里加入“信息泄露惩罚” −α·(beta_hat−beta_star)²。

   

2. **噪声参数**

   

   - 论文常设多个 σᵤ 做敏感性；可在 train.py 循环不同噪声方差，分别保存模型再比较 λ、β 曲线。

   

3. **做市商也用 RL** *(可选)*

   

   - 把 λₜ 看作做市商动作，让第二个 agent 学 λ_t 以最小化 (p_t−v)² + γ·inventory²，然后用 **PettingZoo** / **RLlib** 训练双智能体，更贴近一些多智能体 Kyle 文献。

   





------





## **结论**





- **先在环境里把 λₜ、βₜ 实时存下来** → 最简单即可画“市场深度”曲线。
- **再批量 roll-out 用回归检验 λ** → 可直接与论文表格相比。
- 如需更精细的 Kyle 动态公式，把 λₜ 写成方差的函数即可自动呈现理论的递减深度。





只要补上以上几行记录&回归代码，再跑几十个 episode，就能产出市场深度等论文级指标并与理论线性均衡做一一对照。祝你实验顺利，随时再交流细节！